"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Auth = void 0;
/* eslint-disable security/detect-object-injection */
const constants_1 = require("@toruslabs/constants");
const fetch_node_details_1 = require("@toruslabs/fetch-node-details");
const torus_js_1 = require("@toruslabs/torus.js");
const auth_1 = require("@web3auth/auth");
const base_1 = require("@web3auth/base");
class Web3Auth {
    connected = false;
    options;
    torusUtils = null;
    nodeDetailManager = null;
    privKeyProvider = null;
    currentChainNamespace = base_1.CHAIN_NAMESPACES.EIP155;
    constructor(options) {
        this.validateConstructorOptions(options);
        const network = options.web3AuthNetwork || "mainnet";
        this.options = {
            ...options,
            web3AuthNetwork: network,
            useDKG: options.useDKG !== undefined ? options.useDKG : this.getUseDKGDefaultValue(network),
        };
    }
    get provider() {
        return this.privKeyProvider || null;
    }
    init({ provider }) {
        if (!provider || !provider.currentChainConfig || !provider.currentChainConfig.chainNamespace) {
            throw base_1.WalletInitializationError.invalidParams('provider must be of type "PrivateKeyProvider" and have a valid chainNamespace');
        }
        const { web3AuthNetwork: network } = this.options;
        this.torusUtils = new torus_js_1.Torus({
            enableOneKey: true,
            network,
            clientId: this.options.clientId,
        });
        torus_js_1.Torus.enableLogging(this.options.enableLogging || false);
        this.nodeDetailManager = new fetch_node_details_1.NodeDetailManager({ network, enableLogging: this.options.enableLogging || false });
        this.privKeyProvider = provider;
        this.currentChainNamespace = provider.currentChainConfig.chainNamespace;
    }
    async connect(loginParams) {
        if (!this.torusUtils || !this.nodeDetailManager || !this.privKeyProvider)
            throw base_1.WalletInitializationError.notReady("Please call init first.");
        const { verifier, verifierId, idToken, subVerifierInfoArray } = loginParams;
        if (!verifier || !verifierId || !idToken)
            throw base_1.WalletInitializationError.invalidParams("verifier or verifierId or idToken  required");
        const verifierDetails = { verifier, verifierId };
        const { torusNodeEndpoints, torusIndexes, torusNodePub } = await this.nodeDetailManager.getNodeDetails(verifierDetails);
        let finalIdToken = idToken;
        let finalVerifierParams = { verifier_id: verifierId };
        if (subVerifierInfoArray && subVerifierInfoArray?.length > 0) {
            const aggregateVerifierParams = { verify_params: [], sub_verifier_ids: [], verifier_id: "" };
            const aggregateIdTokenSeeds = [];
            for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
                const userInfo = subVerifierInfoArray[index];
                aggregateVerifierParams.verify_params.push({ verifier_id: verifierId, idtoken: userInfo.idToken });
                aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
                aggregateIdTokenSeeds.push(userInfo.idToken);
            }
            aggregateIdTokenSeeds.sort();
            const inputString = aggregateIdTokenSeeds.join(String.fromCharCode(29));
            const inputBuffer = Buffer.from(inputString, "utf8");
            finalIdToken = (0, torus_js_1.keccak256)(inputBuffer).slice(2);
            aggregateVerifierParams.verifier_id = verifierId;
            finalVerifierParams = aggregateVerifierParams;
        }
        const retrieveSharesResponse = await this.torusUtils.retrieveShares({
            endpoints: torusNodeEndpoints,
            indexes: torusIndexes,
            verifier,
            verifierParams: finalVerifierParams,
            idToken: finalIdToken,
            nodePubkeys: torusNodePub,
            useDkg: this.options.useDKG,
        });
        if (retrieveSharesResponse.metadata.upgraded) {
            throw base_1.WalletLoginError.mfaEnabled();
        }
        const { finalKeyData, oAuthKeyData } = retrieveSharesResponse;
        const privKey = finalKeyData.privKey || oAuthKeyData.privKey;
        if (!privKey)
            throw base_1.WalletLoginError.fromCode(5000, "Unable to get private key from torus nodes");
        let finalPrivKey = privKey.padStart(64, "0");
        if (this.options.usePnPKey) {
            const pnpPrivKey = (0, auth_1.subkey)(finalPrivKey, Buffer.from(this.options.clientId, "base64"));
            finalPrivKey = pnpPrivKey.padStart(64, "0");
        }
        if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.SOLANA) {
            if (!this.privKeyProvider.getEd25519Key) {
                throw base_1.WalletLoginError.fromCode(5000, "Private key provider is not valid, Missing getEd25519Key function");
            }
            finalPrivKey = this.privKeyProvider.getEd25519Key(finalPrivKey);
        }
        await this.privKeyProvider.setupProvider(finalPrivKey);
        this.connected = true;
        return this.privKeyProvider;
    }
    getUseDKGDefaultValue(network) {
        // only dkg flow is supported for legacy networks
        if (constants_1.LEGACY_NETWORKS_ROUTE_MAP[network]) {
            return true;
        }
        // for rest networks both flows are supported, but default is non dkg.
        return false;
    }
    validateConstructorOptions(options) {
        // non dkg flow is not supported in legacy networks
        if (options.useDKG === false && constants_1.LEGACY_NETWORKS_ROUTE_MAP[options.web3AuthNetwork]) {
            throw base_1.WalletInitializationError.invalidParams("useDKG cannot be false for legacy networks");
        }
    }
}
exports.Web3Auth = Web3Auth;
//# sourceMappingURL=Web3Auth.js.map